/**
 * @file math_tests.cpp
 * @author GPT-4
 * @brief Tests generated by GPT-4
 * @version 0.1
 * @date 2023-04-13
 *
 * @copyright Copyright (c) 2023
 *
 */
#include <gtest/gtest.h>

#include "rdr/math_aliases.h"
#include "rdr/math_utils.h"
#include "rdr/rdr.h"

using namespace RDR_NAMESPACE_NAME;

TEST(Math, Cast) {
  Vec3i         a(1, 2, 3);
  volatile auto b = Cast<Float>(a);
}

template <typename T>
void TestDotProduct(const T &a, const T &b, decltype(Dot(a, b)) expected) {
  EXPECT_EQ(Dot(a, b), expected);
}

TEST(Math, DotTest) {
  // Test Vec2f
  TestDotProduct(Vec2f(1, 2), Vec2f(3, 4), 11.0f);

  // Test Vec2i
  TestDotProduct(Vec2i(1, 2), Vec2i(3, 4), 11);

  // Test Vec3f
  TestDotProduct(Vec3f(1, 2, 3), Vec3f(4, 5, 6), 32.0f);

  // Test Vec3i
  TestDotProduct(Vec3i(1, 2, 3), Vec3i(4, 5, 6), 32);
}

template <typename T>
void TestSquareNorm(const T &a, decltype(SquareNorm(a)) expected) {
  EXPECT_EQ(SquareNorm(a), expected);
}

TEST(Math, SquareNormTest) {
  // Test Vec2f
  TestSquareNorm(Vec2f(1, 2), 5.0f);

  // Test Vec2i
  TestSquareNorm(Vec2i(1, 2), 5);

  // Test Vec3f
  TestSquareNorm(Vec3f(1, 2, 3), 14.0f);

  // Test Vec3i
  TestSquareNorm(Vec3i(1, 2, 3), 14);
}

template <typename T>
void TestCrossProduct(const T &a, const T &b, const T &expected) {
  EXPECT_EQ(Cross(a, b), expected);
}

TEST(Math, CrossTest) {
  // Test Vec3f
  TestCrossProduct(Vec3f(1, 0, 0), Vec3f(0, 1, 0), Vec3f(0, 0, 1));

  // Test Vec3i
  TestCrossProduct(Vec3i(1, 0, 0), Vec3i(0, 1, 0), Vec3i(0, 0, 1));
}

template <typename T>
void TestNormalize(const T &a, const T &expected) {
  T result = Normalize(a);
  for (size_t i = 0; i < vec_type<T>::size; ++i) {
    EXPECT_NEAR(result[i], expected[i], 1e-6);
  }
}

TEST(Math, NormalizeTest) {
  // Test Vec2f
  TestNormalize(Vec2f(3, 4), Vec2f(0.6f, 0.8f));

  // Test Vec3f
  TestNormalize(Vec3f(1, 2, 2), Vec3f(1 / 3.0f, 2 / 3.0f, 2 / 3.0f));
}

template <typename T>
void TestMinMax(const T &a, const T &b, const T &expected_min,
                const T &expected_max) {
  EXPECT_EQ(Min(a, b), expected_min);
  EXPECT_EQ(Max(a, b), expected_max);
}

TEST(Math, MinMaxTest) {
  // Test Vec2f
  TestMinMax(Vec2f(1, 4), Vec2f(3, 2), Vec2f(1, 2), Vec2f(3, 4));

  // Test Vec2i
  TestMinMax(Vec2i(1, 4), Vec2i(3, 2), Vec2i(1, 2), Vec2i(3, 4));

  // Test Vec3f
  TestMinMax(Vec3f(1, 4, 3), Vec3f(3, 2, 5), Vec3f(1, 2, 3), Vec3f(3, 4, 5));

  // Test Vec3i
  TestMinMax(Vec3i(1, 4, 3), Vec3i(3, 2, 5), Vec3i(1, 2, 3), Vec3i(3, 4, 5));
}

TEST(Math, UniformSampleSphere) {
  const int   N   = 100000;
  const Float eps = 1e-2;
  Sampler     sampler;
  double      result = 0.0;
  for (int i = 0; i < N; ++i) {
    Vec3f sample = UniformSampleSphere(sampler.get2D());
    Float pdf    = 1 / (4 * PI);
    result += AbsCosTheta(sample) / pdf;
  }

  result /= N;
  EXPECT_NEAR(result, 2 * PI, eps);
}